<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SEDRIS Transmittal Access C++ API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#FFFFFF">

<!-- Generated by Doxygen 1.4.7-20061004 -->
<div class="tabs">
  <ul>
    <li><a href="main.htm"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.htm"><span>Modules</span></a></li>
    <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.htm"><span>Classes</span></a></li>
    <li><a href="files.htm"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.htm"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.htm"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.htm"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.htm"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00635.htm">sedris</a>::<a class="el" href="a00312.htm">seIterator</a></div>
<h1>sedris::seIterator Class Reference</h1><!-- doxytag: class="sedris::seIterator" --><a class="el" href="a00312.htm">seIterator</a> is the generalized iterator for seObject's.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;seIterator.h&gt;</code>
<p>
<a href="a01581.htm">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e5a6b01e76306e75917a4d88d828546c"></a><!-- doxytag: member="sedris::seIterator::seIterator" ref="e5a6b01e76306e75917a4d88d828546c" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#e5a6b01e76306e75917a4d88d828546c">seIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e05219d0fb4846824fbe22b535f4a14"></a><!-- doxytag: member="sedris::seIterator::seIterator" ref="9e05219d0fb4846824fbe22b535f4a14" args="(const seIterator &amp;other)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#9e05219d0fb4846824fbe22b535f4a14">seIterator</a> (const <a class="el" href="a00312.htm">seIterator</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies another iterator's state into this one. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52e30da6c9b1b7787cb89046f72907ec"></a><!-- doxytag: member="sedris::seIterator::~seIterator" ref="52e30da6c9b1b7787cb89046f72907ec" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#52e30da6c9b1b7787cb89046f72907ec">~seIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00312.htm">seIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#32b8d9943220b3b8f233c8078c61699c">operator=</a> (const <a class="el" href="a00312.htm">seIterator</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies another iterator's state into this one.  <a href="#32b8d9943220b3b8f233c8078c61699c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8b688aea0c2b2e7900755dd05ce9047b"></a><!-- doxytag: member="sedris::seIterator::operator==" ref="8b688aea0c2b2e7900755dd05ce9047b" args="(const seIterator &amp;other) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#8b688aea0c2b2e7900755dd05ce9047b">operator==</a> (const <a class="el" href="a00312.htm">seIterator</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the iterators have the same owners, are of the same type, and they will return the same elements on <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2802999219bf7d529a9219d9548e2269"></a><!-- doxytag: member="sedris::seIterator::isValid" ref="2802999219bf7d529a9219d9548e2269" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#2802999219bf7d529a9219d9548e2269">isValid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this iterator handle is valid, don't confuse with <a class="el" href="a00312.htm#e369b2ef8dfe7c2fa9d0dbe5b83dc842">isCompleted()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#e369b2ef8dfe7c2fa9d0dbe5b83dc842">isCompleted</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the iterator will NOT return any more objects (i.e.  <a href="#e369b2ef8dfe7c2fa9d0dbe5b83dc842"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#f5655b2223144bf8d7c61c4017e8d1e6">getCount</a> (<a class="elRef" doxygen="doxy_tags_drm.xml:../drm/" href="../drm/types/SE_DRM_Class.htm">SE_DRM_Class</a> filter=SE_CLS_DRM_NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of objects remaining in the iterator.  <a href="#f5655b2223144bf8d7c61c4017e8d1e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext</a> (<a class="el" href="a00313.htm">seObject</a> &amp;obj, <a class="el" href="a00313.htm">seObject</a> &amp;link_obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the next element and link object from the iterator.  <a href="#6cba602f18db5316be62c25a295eb080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#0f8df1534b195748238981fffd211fd3">getNext</a> (<a class="el" href="a00313.htm">seObject</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the next element from the iterator, ignoring the link object.  <a href="#0f8df1534b195748238981fffd211fd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#ea6318163f312afe8e240ae4196d0050">getNthNext</a> (unsigned int nth, <a class="el" href="a00313.htm">seObject</a> &amp;obj, <a class="el" href="a00313.htm">seObject</a> &amp;link_obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the Nth next element from the iterator.  <a href="#ea6318163f312afe8e240ae4196d0050"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#0d50413cc6adcff5ed86f9d0aa710b97">getNthNext</a> (unsigned int nth, <a class="el" href="a00313.htm">seObject</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the Nth next element from the iterator, ignoring the link object.  <a href="#0d50413cc6adcff5ed86f9d0aa710b97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.htm#53e00055af3fe1cfa02c7514902bf5fd">release</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases the handle to the iterator.  <a href="#53e00055af3fe1cfa02c7514902bf5fd"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="a00312.htm">seIterator</a> is the generalized iterator for seObject's. 
<p>
This class is used to iterate through a list of objects.<p>
The following sample shows how you can use an iterator to retrieve DRM objects of a specific type, using their specific DRM object classes: <div class="fragment"><pre class="fragment">    seDRMPolygon poly;

    ... poly is retrieved from the transmittal

    <a class="code" href="a00312.htm#e5a6b01e76306e75917a4d88d828546c">seIterator</a> iter;
    seDRMVertex vtx;

    poly.getComponentIterator(iter, SE_CLS_DRM_VERTEX)
    <span class="keywordflow">while</span> (iter.getNext(vtx))
    {
        ... process vertex object
    }
</pre></div><p>
The following sample shows how you can use an iterator to retrieve and process all the components of a DRM object in a generic way: <div class="fragment"><pre class="fragment">    ... aggr_obj is retrieved from the transmittal

    <a class="code" href="a00312.htm#e5a6b01e76306e75917a4d88d828546c">seIterator</a> iter;
    seObject comp_obj, link_obj;

    aggr_obj.getComponentIterator(iter)
    <span class="keywordflow">while</span> (iter.getNext(comp_obj, link_obj))
    {
        <span class="keywordflow">if</span> (comp_obj.isA(SE_CLS_DRM_UNION_OF_PRIMITIVE_GEOMETRY))
        {
            seDRMUnionOfPrimitiveGeometry uofp(comp_obj);

            ... process uofp
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (comp_obj.isA(...))
        {
            ... process another type
        }
        ...
    }
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The ITR behaviour of an <a class="el" href="a00312.htm">seIterator</a> is determined by the ITR behaviour of the <a class="el" href="a00316.htm">seWorkspace</a> at the moment the iterator is created. See <a class="el" href="a00316.htm#6a09c85986f3056978af14bb5275dc06">seWorkspace::setITRBehaviour()</a> and <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a> for more information. </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Warren Macchi (Accent Geographic) </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00313.htm#f7562705b4fc45bf2a638b60291d3c01">seObject::getComponentIterator</a>, <a class="el" href="a00313.htm#29b5241e587563c862b3182e6ca9c3ee">seObject::getAssociateIterator</a>, <a class="el" href="a00313.htm#c45a6659b07b7dd86da36c54385303c4">seObject::getAggregateIterator</a>, <a class="el" href="a00313.htm">seObject</a>, <a class="el" href="a00315.htm">seTransmittal</a>, <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a>, <a class="el" href="a00316.htm#6a09c85986f3056978af14bb5275dc06">seWorkspace::setITRBehaviour()</a> </dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="32b8d9943220b3b8f233c8078c61699c"></a><!-- doxytag: member="sedris::seIterator::operator=" ref="32b8d9943220b3b8f233c8078c61699c" args="(const seIterator &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00312.htm">seIterator</a>&amp; sedris::seIterator::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00312.htm">seIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies another iterator's state into this one. 
<p>
You can use this operator to store, for example, a temporary iterator if you need to look ahead somewhat, and then return to where you left off. <dl class="note" compact><dt><b>Note:</b></dt><dd>After the iterators are copied, they will both return the same objects after a similar call to <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a> on them. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e369b2ef8dfe7c2fa9d0dbe5b83dc842"></a><!-- doxytag: member="sedris::seIterator::isCompleted" ref="e369b2ef8dfe7c2fa9d0dbe5b83dc842" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seIterator::isCompleted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the iterator will NOT return any more objects (i.e. 
<p>
<a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a> will return false). Sample usage: <div class="fragment"><pre class="fragment">            <span class="keywordflow">while</span> (!iter.isCompleted())
            {
                ... get next object and process
            }
</pre></div> 
</div>
</div><p>
<a class="anchor" name="f5655b2223144bf8d7c61c4017e8d1e6"></a><!-- doxytag: member="sedris::seIterator::getCount" ref="f5655b2223144bf8d7c61c4017e8d1e6" args="(SE_DRM_Class filter=SE_CLS_DRM_NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int sedris::seIterator::getCount           </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="doxy_tags_drm.xml:../drm/" href="../drm/types/SE_DRM_Class.htm">SE_DRM_Class</a>&nbsp;</td>
          <td class="paramname"> <em>filter</em> = <code>SE_CLS_DRM_NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of objects remaining in the iterator. 
<p>
An optional DRM class can be used to filter the returned count.<p>
For performance reasons do not use this method as a replacement for <a class="el" href="a00312.htm#e369b2ef8dfe7c2fa9d0dbe5b83dc842">isCompleted()</a> or use this method as part of a loop test. For example, rather than seeing if an iterator is empty by doing: <div class="fragment"><pre class="fragment">            <span class="keywordflow">while</span> (iter.getCount() &gt; 0) <span class="comment">// NOT VERY EFFICIENT</span>
            {
                ... retrieve and process objects
            }
</pre></div> use the following instead: <div class="fragment"><pre class="fragment">            <span class="keywordflow">while</span> (!iter.isCompleted()) <span class="comment">// BETTER</span>
            {
                ... retrieve and process objects
            }
</pre></div><p>
If you do need to loop based on the number of objects in the iterator, use as follows: <div class="fragment"><pre class="fragment">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = iter.getCount();

            <span class="keywordflow">for</span> (i=0, i &lt; count; i++)
            {
                ... retrieve and process ith object
            }
</pre></div><p>
An example of using the filter type to get a count ahead of processing is: <div class="fragment"><pre class="fragment">            <a class="code" href="a00312.htm#e5a6b01e76306e75917a4d88d828546c">seIterator</a> iter;
            seObject comp_obj, link_obj;

            poly_obj.getComponentIterator(iter);

            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex_count = iter.getCount(SE_CLS_DRM_VERTEX);
            <span class="comment">// here you may allocate an array based on vertex_count</span>

            <span class="keywordflow">while</span> (iter.getNext(comp_obj, link_obj))
            {
                <span class="comment">// process component, which may or may not be a vertex!</span>
            }
</pre></div><p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If the iterator was created with a DRM filter type (i.e. the filter type was not SE_CLS_DRM_NULL) and you pass in a different DRM class type to this method, the result is undefined unless the type passed-in is a subclass of the type used to initialize the iterator. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if the count could not be retrieved (due to a file failure, a failed ITR resolution, etc.) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filter</em>&nbsp;</td><td>in: DRM class to filter the current iterator set </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of elements left </dd></dl>

</div>
</div><p>
<a class="anchor" name="6cba602f18db5316be62c25a295eb080"></a><!-- doxytag: member="sedris::seIterator::getNext" ref="6cba602f18db5316be62c25a295eb080" args="(seObject &amp;obj, seObject &amp;link_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seIterator::getNext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>link_obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the next element and link object from the iterator. 
<p>
As a convenience, this method returns false when the iterator is empty. Hence, you can use code like <div class="fragment"><pre class="fragment">            <a class="code" href="a00312.htm#e5a6b01e76306e75917a4d88d828546c">seIterator</a> iter;
            seObject comp_obj, link_obj;

            some_obj.getComponentIterator(iter);

            <span class="keywordflow">while</span> (iter.getNext(comp_obj, link_obj))
            {
                ... use comp_obj and link_obj as needed
            }
</pre></div><p>
However, note that the above will not let you continue the loop in the case of an exception occurring in the <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a> call. If you do want to continue the loop, then you should use <a class="el" href="a00312.htm#e369b2ef8dfe7c2fa9d0dbe5b83dc842">isCompleted()</a> for the loop test and call <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a> inside the loop in a try/catch statement: <div class="fragment"><pre class="fragment">            <a class="code" href="a00312.htm#e5a6b01e76306e75917a4d88d828546c">seIterator</a> iter;
            seObject comp_obj, link_obj;

            some_obj.getComponentIterator(iter);

            <span class="keywordflow">while</span> (!iter.isCompleted())
            {
                <span class="keywordflow">try</span> {
                    iter.getNext(comp_obj, link_obj);
                    ... use comp_obj and link_obj as needed
                } <span class="keywordflow">catch</span> ( seException&amp; e ) {
                    ... process exception
                }
            }
</pre></div><p>
The ITR behaviour of an iterator is dependent on the ITR behaviour set at the workspace level (see <a class="el" href="a00316.htm#6a09c85986f3056978af14bb5275dc06">seWorkspace::setITRBehaviour()</a>) when the iterator is created. Iterators are typically created by calling one of the "get" iterator methods of an <a class="el" href="a00313.htm">seObject</a> (for example <a class="el" href="a00313.htm#f7562705b4fc45bf2a638b60291d3c01">seObject::getComponentIterator()</a>). After the iterator is created, changing the workspace ITR behaviour has no effect on the iterator.<p>
The ITR behaviour value is interpreted as follows: <ul>
<li>
If ITR behaviour is SE_ITRBEH_RESOLVE, then all objects returned by the API will be resolved objects. If an object cannot be resolved (for example the referenced transmittal is missing) then an exception will occur (the exception type will be dependent on the failed step, for example it could be UNRESOLVED_TRANSMITTAL, UNPUBLISHED_OBJECT, or some other exception type). </li>
<li>
If ITR behaviour is SE_ITRBEH_REPORT, then when the iterator encounters an ITR reference it will return an unresolved object, no matter what its DRM type may be. You can call <a class="el" href="a00313.htm#dc1067c47bd91bff1830c5782eed48f2">seObject::resolve()</a> to attempt to resolve the object if you need to. Note that the current filter DRM class for the iterator is ignored for ITR references when using SE_ITRBEH_REPORT. Hence, for this case, you should not use seDRMBase-derived classes as parameters to <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a>. </li>
<li>
If ITR behaviour is SE_ITRBEH_IGNORE, then ITR references are skipped by the iterator and are never returned. </li>
</ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If there is no link object associated with the next object, the link object parameter is set to an invalid object handle (i.e. you can use <a class="el" href="a00313.htm#0ee3c5261c56864e0ae9a93bee79035b">seObject::isValid()</a> to see if a link object was available). <p>
This method respects the DRM ordering of ordered classes. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If you use one of the seDRMBase-derived classes as parameters to this method, you must ensure that the derived type will be able to hold a reference to whatever object will be returned, or an exception will occur. If you don't know what type will be returned, you can pass in a base class (such as <a class="el" href="a00313.htm">seObject</a>) and then get the type of the object by using <a class="el" href="a00313.htm#256b847c72e944db1101a06246581594">seObject::getDRMClass()</a>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#6a09c85986f3056978af14bb5275dc06">seWorkspace::setITRBehaviour()</a>, <a class="el" href="a00313.htm#fb8d8d28e3887352fddc3bd22f943fe0">seObject::isResolved()</a> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if an error occurs. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: a handle to store the next object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>link_obj</em>&nbsp;</td><td>in/out: a handle to store the next link object (if part of the relation) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0f8df1534b195748238981fffd211fd3"></a><!-- doxytag: member="sedris::seIterator::getNext" ref="0f8df1534b195748238981fffd211fd3" args="(seObject &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seIterator::getNext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the next element from the iterator, ignoring the link object. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getNext(seObject, seObject) </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if an error occurs. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: a handle to store the next object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ea6318163f312afe8e240ae4196d0050"></a><!-- doxytag: member="sedris::seIterator::getNthNext" ref="ea6318163f312afe8e240ae4196d0050" args="(unsigned int nth, seObject &amp;obj, seObject &amp;link_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seIterator::getNthNext           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>link_obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the Nth next element from the iterator. 
<p>
This is a convenience method that skips over the iterator list and returns the next Nth element in the list. When "nth" equals 1, this method is equivalent to calling <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a>. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>Since an iterator is a sequential list, once you request an nth object, calling <a class="el" href="a00312.htm#ea6318163f312afe8e240ae4196d0050">getNthNext()</a> with the same nth value will NOT return the same object. That is, an iterator always moves forward in its list of objects, never backward. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getNext(seObject, seObject) </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if an error occurs. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nth</em>&nbsp;</td><td>in: a number greater than or equal to 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: a handle to store the next object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>link_obj</em>&nbsp;</td><td>in/out: a handle to store the next link object (if available) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d50413cc6adcff5ed86f9d0aa710b97"></a><!-- doxytag: member="sedris::seIterator::getNthNext" ref="0d50413cc6adcff5ed86f9d0aa710b97" args="(unsigned int nth, seObject &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seIterator::getNthNext           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the Nth next element from the iterator, ignoring the link object. 
<p>
This is a convenience method that skips over the iterator list and returns the next Nth element in the list. When "nth" equals 1, this method is equivalent to calling <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">getNext()</a>. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>Since an iterator is a sequential list, once you request an nth object, calling <a class="el" href="a00312.htm#ea6318163f312afe8e240ae4196d0050">getNthNext()</a> with the same nth value will NOT return the same object. That is, an iterator always moves forward in its list of objects, never backward. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method respects the DRM ordering of ordered classes. <p>
If there is no <code>nth</code> element (i.e. this method returns false), no changes are made to the iterator so that you can continue iterating through its elements as if no method was called. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getNthNext(unsigned int, seObject, seObject) </dd></dl>

</div>
</div><p>
<a class="anchor" name="53e00055af3fe1cfa02c7514902bf5fd"></a><!-- doxytag: member="sedris::seIterator::release" ref="53e00055af3fe1cfa02c7514902bf5fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seIterator::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the handle to the iterator. 
<p>
Generally there is no need to call this method, since <a class="el" href="a00312.htm#53e00055af3fe1cfa02c7514902bf5fd">release()</a> is called by any change of handle or when the object goes out of scope. 
</div>
</div><p>
<hr size="1">
<table width="100%">
<tr valign="middle">
<td align="left"><b>SEDRIS Transmittal Access C++ API</b></td>
<td align="right"><b>Version 4.1.4 - 14 Sep 2010</b></td>
</tr>
<tr valign="middle">
<td align="left">Copyright &copy; 2010 <a href="http://www.sedris.org">SEDRIS</a>&trade;</td>
<td align="right">Docs by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.4.7-20061004</td>
</tr>
</table>
</body>
</html>
