<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SEDRIS Transmittal Access C++ API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#FFFFFF">

<!-- Generated by Doxygen 1.4.7-20061004 -->
<div class="tabs">
  <ul>
    <li><a href="main.htm"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.htm"><span>Modules</span></a></li>
    <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.htm"><span>Classes</span></a></li>
    <li><a href="files.htm"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.htm"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.htm"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.htm"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.htm"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00635.htm">sedris</a>::<a class="el" href="a00315.htm">seTransmittal</a></div>
<h1>sedris::seTransmittal Class Reference</h1><!-- doxytag: class="sedris::seTransmittal" -->Access to transmittals.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;seTransmittal.h&gt;</code>
<p>
<a href="a01586.htm">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d42f7ee7733c3ab5ca850846ffba456"></a><!-- doxytag: member="sedris::seTransmittal::seTransmittal" ref="6d42f7ee7733c3ab5ca850846ffba456" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#6d42f7ee7733c3ab5ca850846ffba456">seTransmittal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#a1ecb2e9106a97e86ac9db36310b7675">seTransmittal</a> (const <a class="el" href="a00315.htm">seTransmittal</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor, same as <a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo()</a>.  <a href="#a1ecb2e9106a97e86ac9db36310b7675"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#5bbddf2649369f34bff7fbb1e0abd745">~seTransmittal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor, releases the transmittal handle.  <a href="#5bbddf2649369f34bff7fbb1e0abd745"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#c702771a52eb92c5698b014aaec88834">operator=</a> (const <a class="el" href="a00315.htm">seTransmittal</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy operator, same as <a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo()</a>.  <a href="#c702771a52eb92c5698b014aaec88834"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#e3d6ca93ebd27b3613dc30311698b544">isValid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this transmittal handle is valid.  <a href="#e3d6ca93ebd27b3613dc30311698b544"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5be7994f496a8ffd89654011f89b7f46"></a><!-- doxytag: member="sedris::seTransmittal::isOpened" ref="5be7994f496a8ffd89654011f89b7f46" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#5be7994f496a8ffd89654011f89b7f46">isOpened</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this transmittal is opened. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#7f408f82b9e5ab56a1efc72dc0aabc99">isEditable</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this transmittal is opened and editable.  <a href="#7f408f82b9e5ab56a1efc72dc0aabc99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13f2810fa21ce8bf118e942e0a9211ea"></a><!-- doxytag: member="sedris::seTransmittal::isModified" ref="13f2810fa21ce8bf118e942e0a9211ea" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#13f2810fa21ce8bf118e942e0a9211ea">isModified</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this transmittal was modified (for example if objects were added, deleted, or changed). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#b265292bf31c3bcda4e71608bf750863">getFileName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the file location of this transmittal.  <a href="#b265292bf31c3bcda4e71608bf750863"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="92489ee8a7ef5af47163deddb7876f81"></a><!-- doxytag: member="sedris::seTransmittal::getAccessMode" ref="92489ee8a7ef5af47163deddb7876f81" args="() const " -->
virtual SE_Access_Mode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#92489ee8a7ef5af47163deddb7876f81">getAccessMode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the access mode used to open this transmittal. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual SE_Encoding&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#d80f6639e65e65d19ee0fa4ac9f4a208">getEncoding</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the encoding type of this transmittal.  <a href="#d80f6639e65e65d19ee0fa4ac9f4a208"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#890e458a0f7ad1932cc34518434a3ae7">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the transmittal.  <a href="#890e458a0f7ad1932cc34518434a3ae7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#1e00bf09a25fbe375fdc15da226baa00">getRootObject</a> (<a class="el" href="a00313.htm">seObject</a> &amp;obj) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the object that has been stored as the root of the transmittal hierarchy.  <a href="#1e00bf09a25fbe375fdc15da226baa00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#5dfcbafa362a21019a8550386e9eb964">setRootObject</a> (<a class="el" href="a00313.htm">seObject</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the root object for the transmittal hierarchy.  <a href="#5dfcbafa362a21019a8550386e9eb964"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#7d4feeeb32265b0d05183a6164f17e4c">createObject</a> (<a class="el" href="a00313.htm">seObject</a> &amp;obj, <a class="elRef" doxygen="doxy_tags_drm.xml:../drm/" href="../drm/types/SE_DRM_Class.htm">SE_DRM_Class</a> type=SE_CLS_DRM_NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a transmittal object of a specific DRM type.  <a href="#7d4feeeb32265b0d05183a6164f17e4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#9722e68bd8f69c929ecd6a18673f4cb6">deleteObject</a> (<a class="el" href="a00313.htm">seObject</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an object from the transmittal.  <a href="#9722e68bd8f69c929ecd6a18673f4cb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#b001a7ad92fb10c7a1a90c8bef3b5312">deleteObjectTree</a> (<a class="el" href="a00313.htm">seObject</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an object and all its descendants from the transmittal by recursively removing all its relationships.  <a href="#b001a7ad92fb10c7a1a90c8bef3b5312"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#238ffa1c07ee14dcefc38aea0a302730">getObjectFromID</a> (const char *str_obj_ID, <a class="el" href="a00313.htm">seObject</a> &amp;obj) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object in the transmittal by its identifier.  <a href="#238ffa1c07ee14dcefc38aea0a302730"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#f9ad51fcadfaf6af103f4eab1e36bfae">getPublishedObject</a> (const char *obj_label, <a class="el" href="a00313.htm">seObject</a> &amp;obj) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object in the transmittal based on its published label.  <a href="#f9ad51fcadfaf6af103f4eab1e36bfae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#2f9a95d2d8cd1b52d5844cf4deca2cb2">getPublishedObjectsIterator</a> (<a class="el" href="a00312.htm">seIterator</a> &amp;iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes an iterator with the list of objects published by the transmittal for possible reference using ITR.  <a href="#2f9a95d2d8cd1b52d5844cf4deca2cb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#3aa9fd8e89b10029e2640b05e1d83cb7">setURN</a> (const char *urn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set (or modify) the URN for the transmittal.  <a href="#3aa9fd8e89b10029e2640b05e1d83cb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#fa2f09bfaf8f423e2e44a51c5cfbea6d">getURN</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the transmittal URN associated with this transmittal.  <a href="#fa2f09bfaf8f423e2e44a51c5cfbea6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#23d3d34b13e880d051a2f1eac6e86a61">getITRReferenceCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of ITR referenced transmittals.  <a href="#23d3d34b13e880d051a2f1eac6e86a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#54d7717cd87806b86510fe3d439b33d2">getITRReference</a> (unsigned int urn_index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the URN for an ITR referenced transmittal by index.  <a href="#54d7717cd87806b86510fe3d439b33d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#4ec20bb1cf2e5251c50649b604cbfc67">getITRReferenceLabelCount</a> (unsigned int urn_index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of labels being used to reference objects in a particular URN-referenced transmittal (by URN index).  <a href="#4ec20bb1cf2e5251c50649b604cbfc67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#3addc269841882a309aa36413501560e">getITRReferenceLabel</a> (unsigned int urn_index, unsigned int label_index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the label (by label index) being used to reference an object in a particular URN-referenced transmittal (by URN index).  <a href="#3addc269841882a309aa36413501560e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#3335c551211928de6c801372ba91fa0b">getUniqueID</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the transmittal unique identifier.  <a href="#3335c551211928de6c801372ba91fa0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo</a> (<a class="el" href="a00315.htm">seTransmittal</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clones this instance handle into another transmittal handle.  <a href="#09b2a5f6dd89fad3c11639229684dcae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#544346d889fb0d19419a8beef9ac8509">isSameAs</a> (const <a class="el" href="a00315.htm">seTransmittal</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the transmittal passed in is a clone of this one (i.e.  <a href="#544346d889fb0d19419a8beef9ac8509"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#ba182f50d1f79e170e70a17d78cec0d2">release</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases the handle to the transmittal.  <a href="#ba182f50d1f79e170e70a17d78cec0d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.htm#b2f867f56d8fae31f4ca71e09af5d7be">isInWorkspace</a> (const <a class="el" href="a00316.htm">seWorkspace</a> &amp;wksp) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this transmittal was opened in the passed-in workspace.  <a href="#b2f867f56d8fae31f4ca71e09af5d7be"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Access to transmittals. 
<p>
The <a class="el" href="a00315.htm">seTransmittal</a> class is used to gain access to SEDRIS transmittals. Other metadata in transmittals is also accessed through this class (see for example <a class="el" href="a00315.htm#23d3d34b13e880d051a2f1eac6e86a61">getITRReferenceCount()</a>). The following example demonstrates the creation, closing, and re-opening of a transmittal: <div class="fragment"><pre class="fragment">    seWorkspace wksp;
    <a class="code" href="a00315.htm#6d42f7ee7733c3ab5ca850846ffba456">seTransmittal</a> xmtal;

    <span class="comment">// create the transmittal</span>
    wksp.createTransmittal(fileName, xmtal);
    ... create Transmittal Root object as needed
    xmtal.setRoot(rootObj);
    ... add top level objects as needed
    ... add a hierarchy of objects as needed
    <span class="comment">// close the transmittal</span>
    xmtal.close();

    <span class="comment">// open the transmittal</span>
    wksp.openTransmittalByFile(fileName, xmtal);
    xmtal.getRootObject(rootObj);
    ... process objects
</pre></div> <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>on error. </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Warren Macchi (Accent Geographic) </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm">seWorkspace</a>, <a class="el" href="a00313.htm">seObject</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a1ecb2e9106a97e86ac9db36310b7675"></a><!-- doxytag: member="sedris::seTransmittal::seTransmittal" ref="a1ecb2e9106a97e86ac9db36310b7675" args="(const seTransmittal &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sedris::seTransmittal::seTransmittal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor, same as <a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo()</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5bbddf2649369f34bff7fbb1e0abd745"></a><!-- doxytag: member="sedris::seTransmittal::~seTransmittal" ref="5bbddf2649369f34bff7fbb1e0abd745" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sedris::seTransmittal::~seTransmittal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor, releases the transmittal handle. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The transmittal is NOT automatically closed. This is to allow to continue work on a transmittal even if a handle to it is not currently available (but you can retrieve it from an <a class="el" href="a00313.htm">seObject</a> handle or from the <a class="el" href="a00316.htm">seWorkspace</a> handle). However, the transmittal IS closed when the workspace handle it was opened under goes out of scope. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#fc80507cab850e05d60bef7edc716940">seWorkspace::~seWorkspace</a>, <a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">seWorkspace::close()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c702771a52eb92c5698b014aaec88834"></a><!-- doxytag: member="sedris::seTransmittal::operator=" ref="c702771a52eb92c5698b014aaec88834" args="(const seTransmittal &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00315.htm">seTransmittal</a>&amp; sedris::seTransmittal::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy operator, same as <a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo()</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This operator only makes one <a class="el" href="a00315.htm">seTransmittal</a> handle point to the same transmittal as another handle. This method is NOT used to copy an actual transmittal's data. See <a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo()</a> for more details. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#09b2a5f6dd89fad3c11639229684dcae">cloneTo()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3d6ca93ebd27b3613dc30311698b544"></a><!-- doxytag: member="sedris::seTransmittal::isValid" ref="e3d6ca93ebd27b3613dc30311698b544" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seTransmittal::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this transmittal handle is valid. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Transmittal handles can remain valid even after the transmittal is closed. However, minimal operations can be performed when the transmittal is closed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f408f82b9e5ab56a1efc72dc0aabc99"></a><!-- doxytag: member="sedris::seTransmittal::isEditable" ref="7f408f82b9e5ab56a1efc72dc0aabc99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seTransmittal::isEditable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this transmittal is opened and editable. 
<p>
A transmittal is "editable" if it is opened in create or edit mode. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#92489ee8a7ef5af47163deddb7876f81">getAccessMode()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b265292bf31c3bcda4e71608bf750863"></a><!-- doxytag: member="sedris::seTransmittal::getFileName" ref="b265292bf31c3bcda4e71608bf750863" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seTransmittal::getFileName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the file location of this transmittal. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>

</div>
</div><p>
<a class="anchor" name="d80f6639e65e65d19ee0fa4ac9f4a208"></a><!-- doxytag: member="sedris::seTransmittal::getEncoding" ref="d80f6639e65e65d19ee0fa4ac9f4a208" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SE_Encoding sedris::seTransmittal::getEncoding           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the encoding type of this transmittal. 
<p>
Encoding identifiers are used to differentiate between storage mechanisms for SEDRIS transmittals. SEDRIS transmittals stored in STF format return the encoding type SE_ENC_STF. 
</div>
</div><p>
<a class="anchor" name="890e458a0f7ad1932cc34518434a3ae7"></a><!-- doxytag: member="sedris::seTransmittal::close" ref="890e458a0f7ad1932cc34518434a3ae7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the transmittal. 
<p>
Closing a transmittal forces the writing of all opened and edited objects. You do not need to call <a class="el" href="a00315.htm#890e458a0f7ad1932cc34518434a3ae7">close()</a> explicitly if you intend the transmittal to be closed when the workspace handle goes out of scope. So for example, this code is perfectly legal since the transmittal is closed when the variable "wksp" goes out of scope: <div class="fragment"><pre class="fragment">            {
                seWorkspace wksp;
                <a class="code" href="a00315.htm#6d42f7ee7733c3ab5ca850846ffba456">seTransmittal</a> xmtal;

                wksp.openTransmittalByFile(...);
                ... work on transmittal
                ... let wksp and xmtal go out of scope
            }
</pre></div> However, if you intend to reopen a previously opened transmittal in the same workspace and the workspace handle is still valid (i.e. it hasn't gone out of scope or <a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">seWorkspace::close()</a> was not called), then you will need to explicitly call the <a class="el" href="a00315.htm#890e458a0f7ad1932cc34518434a3ae7">close()</a> method to close the transmittal handle or the open call will fail (since the transmittal is still opened in the workspace). For example, the following will produce a "transmittal already opened" exception: <div class="fragment"><pre class="fragment">            {
                seWorkspace wksp;
                <a class="code" href="a00315.htm#6d42f7ee7733c3ab5ca850846ffba456">seTransmittal</a> xmtal;

                wksp.createTransmittal(<span class="stringliteral">"my_test.stf"</span>);
                ... work on transmittal

                wksp.openTransmittal(<span class="stringliteral">"my_test.stf"</span>); &lt;&lt;&lt; EXCEPTION
            }
</pre></div> but the following will work OK: <div class="fragment"><pre class="fragment">            {
                seWorkspace wksp;
                <a class="code" href="a00315.htm#6d42f7ee7733c3ab5ca850846ffba456">seTransmittal</a> xmtal;

                wksp.createTransmittal(<span class="stringliteral">"my_test.stf"</span>);
                ... work on transmittal

                xmtal.close(); <span class="comment">// explicit close of transmittal</span>

                wksp.openTransmittal(<span class="stringliteral">"my_test.stf"</span>); <span class="comment">// Now OK</span>
            }
</pre></div> <dl class="note" compact><dt><b>Note:</b></dt><dd>All opened transmittals in a workspace are automatically closed when the workspace handle goes out of scope. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If you close a transmittal, all other <a class="el" href="a00315.htm">seTransmittal</a> handles referring to the same transmittal will also become closed. If you just want to release the handle to the transmittal but not really close it, you can use <a class="el" href="a00315.htm#ba182f50d1f79e170e70a17d78cec0d2">release()</a> instead, or just let the handle go out of scope. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e00bf09a25fbe375fdc15da226baa00"></a><!-- doxytag: member="sedris::seTransmittal::getRootObject" ref="1e00bf09a25fbe375fdc15da226baa00" args="(seObject &amp;obj) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::getRootObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the object that has been stored as the root of the transmittal hierarchy. 
<p>
Example code that retrieves the &lt;Transmittal_Root&gt;: <div class="fragment"><pre class="fragment">            seWorkspace wksp;
            <a class="code" href="a00315.htm#6d42f7ee7733c3ab5ca850846ffba456">seTransmittal</a> xmtal;
            seDRMTransmittalRoot troot;

            <span class="keywordflow">try</span>
            {
                wksp.openTransmittalByFile(...);
                xmtal.getRootObject(troot);
                ... work on transmittal
            }
            ...
</pre></div> <dl class="note" compact><dt><b>Note:</b></dt><dd>Currently the root object for a transmittal should be a &lt;Transmittal_Root&gt; object, but the API does not currently enforce neither the setting of the root object nor the type being used. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>As currently implemented, if the root object is not set while creating a transmittal, the first object created is the default root object. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#5dfcbafa362a21019a8550386e9eb964">setRootObject()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: the handle to store the root object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5dfcbafa362a21019a8550386e9eb964"></a><!-- doxytag: member="sedris::seTransmittal::setRootObject" ref="5dfcbafa362a21019a8550386e9eb964" args="(seObject &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::setRootObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the root object for the transmittal hierarchy. 
<p>
The root object of a transmittal is the root of the DRM hierarchy stored in the transmittal. You can continue adding relationships to the root object after calling this method. <dl class="note" compact><dt><b>Note:</b></dt><dd>If already set, this call replaces the previous root object. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Calling this function will permanently change the root object of the transmittal. If the transmittal already has a root object, you must remove the previous root object's relationships in order to avoid orphaning objects within the transmittal. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#1e00bf09a25fbe375fdc15da226baa00">getRootObject()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in: the new root object for the transmittal </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d4feeeb32265b0d05183a6164f17e4c"></a><!-- doxytag: member="sedris::seTransmittal::createObject" ref="7d4feeeb32265b0d05183a6164f17e4c" args="(seObject &amp;obj, SE_DRM_Class type=SE_CLS_DRM_NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::createObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" doxygen="doxy_tags_drm.xml:../drm/" href="../drm/types/SE_DRM_Class.htm">SE_DRM_Class</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>SE_CLS_DRM_NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a transmittal object of a specific DRM type. 
<p>
The object created can only be used within the transmittal that created it. That is, you can't add objects from one transmittal into another.<p>
You can pass seDRMBase-derived concrete DRM classes to this method, in which case you don't need to specify the DRM type since it is implicit by the class of the parameter. For example, you can do: <div class="fragment"><pre class="fragment">            seDRMAccess access;

            xmtal.createObject(access);
            ...
</pre></div> instead of: <div class="fragment"><pre class="fragment">            seDRMAccess access;

            xmtal.createObject(access, SE_CLS_DRM_ACCESS);
            ...
</pre></div><p>
If you do pass a true <a class="el" href="a00313.htm">seObject</a> to this method, then you MUST provide a concrete DRM class for the type parameter or an exception will occur. For example: <div class="fragment"><pre class="fragment">            seObject troot;

            xmtal.createObject(troot, SE_CLS_DRM_TRANSMITTAL_ROOT);
            ...
</pre></div> <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00014.htm">seDRMBase</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: a handle to store the created object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>in (optional): the class type of DRM object to create </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9722e68bd8f69c929ecd6a18673f4cb6"></a><!-- doxytag: member="sedris::seTransmittal::deleteObject" ref="9722e68bd8f69c929ecd6a18673f4cb6" args="(seObject &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::deleteObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes an object from the transmittal. 
<p>
Prior to calling this function, the user must have removed all relationships that <code>obj</code> has with other objects. If the object still has aggregates, components, or associates an exception will be thrown.<p>
In addition, note that deleting <code>obj</code> from the transmittal does not automatically delete its component sub-tree. (This would not be valid for the general case, since part of <code>obj's</code> component sub-tree might be shared with other objects). Similarly, none of <code>obj's</code> associates are deleted when <code>obj</code> is deleted. See <a class="el" href="a00315.htm#b001a7ad92fb10c7a1a90c8bef3b5312">deleteObjectTree()</a> for an alternative way of removing a whole sub-tree at once.<p>
The transmittal must be editable for this operation to succeed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Once an object is deleted from the transmittal, the object handle should be released (or left to go out of scope). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#b001a7ad92fb10c7a1a90c8bef3b5312">deleteObjectTree()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in: the object to be deleted from the transmittal </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b001a7ad92fb10c7a1a90c8bef3b5312"></a><!-- doxytag: member="sedris::seTransmittal::deleteObjectTree" ref="b001a7ad92fb10c7a1a90c8bef3b5312" args="(seObject &amp;obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::deleteObjectTree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes an object and all its descendants from the transmittal by recursively removing all its relationships. 
<p>
This method removes the object passed in from its parent and deletes all its component objects. Since objects can be shared with other parts of the transmittal, the behaviour is to skip deletion of shared objects (but they are still removed as components of objects in the tree).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method will detach the object passed in from all of its parents, so you do not need to do this. For example, if you want to remove an &lt;Image&gt; from the transmittal you can just pass in the &lt;Image&gt; object without removing it from the &lt;Image Library&gt; (but make sure that no associations exist from other parts of the transmittal to the &lt;Image&gt; object, see the warnings). <p>
If the object passed-in is being shared then no action is taken. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This method may not be able to remove all the associations to the object or its descendants (e.g. one-way relationships), so dangling references may remain. It is the responsibility of the caller to remove one-way associations from other objects in the transmittal to objects in the tree to be deleted. <p>
Be careful when using this method in the presence of ITR references, since the deletion could proceed across the referenced transmittals. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#9722e68bd8f69c929ecd6a18673f4cb6">deleteObject()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in: the root of the object tree to be deleted from the transmittal </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="238ffa1c07ee14dcefc38aea0a302730"></a><!-- doxytag: member="sedris::seTransmittal::getObjectFromID" ref="238ffa1c07ee14dcefc38aea0a302730" args="(const char *str_obj_ID, seObject &amp;obj) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::getObjectFromID           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str_obj_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an object in the transmittal by its identifier. 
<p>
Every object in a transmittal has an identifier that can be used to refer to it. If you have the identifier for an object (see <a class="el" href="a00313.htm#a3eefb98306ddc9dee3630ab8d90e591">seObject::getID()</a>), you can use this method to retrieve that object directly without having to traverse the transmittal hierarchy. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00313.htm#a3eefb98306ddc9dee3630ab8d90e591">seObject::getID()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str_obj_ID</em>&nbsp;</td><td>in: the string object identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: the object matching the identifier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if the object could not be retrieved </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9ad51fcadfaf6af103f4eab1e36bfae"></a><!-- doxytag: member="sedris::seTransmittal::getPublishedObject" ref="f9ad51fcadfaf6af103f4eab1e36bfae" args="(const char *obj_label, seObject &amp;obj) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::getPublishedObject           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>obj_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an object in the transmittal based on its published label. 
<p>
An object that is published is available for reference from other transmittals using ITR. This method allows for direct access to a particular object based on the label that was used to publish it. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00313.htm#4ab4f8fb03e7849e83fa3ddab0c8c5f3">seObject::publish()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj_label</em>&nbsp;</td><td>in: the string object label </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: a reference to the object with the given label </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if there is no object published under the given label </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2f9a95d2d8cd1b52d5844cf4deca2cb2"></a><!-- doxytag: member="sedris::seTransmittal::getPublishedObjectsIterator" ref="2f9a95d2d8cd1b52d5844cf4deca2cb2" args="(seIterator &amp;iter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::getPublishedObjectsIterator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00312.htm">seIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes an iterator with the list of objects published by the transmittal for possible reference using ITR. 
<p>
You can use this method to get a hold of all the published objects in a transmittal. Sample usage: <div class="fragment"><pre class="fragment">            seIterator iter;
            seObject obj;

            xmtal.getPublishedObjectsIterator(iter);
            <span class="keywordflow">while</span> (iter.getNext(obj))
            {
                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, cnt = obj.getPublishedLabelCount();

                <span class="keywordflow">for</span> (i=0; i &lt; cnt; i++)
                {
                    cout &lt;&lt; obj.getPublishedLabel(i) &lt;&lt; endl;
                }
            }
</pre></div> <dl class="note" compact><dt><b>Note:</b></dt><dd>The returned objects are unique objects in a transmittal. That is, if an object A is published under multiple labels, then the iterator will return object A only once. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>in/out: an iterator handle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3aa9fd8e89b10029e2640b05e1d83cb7"></a><!-- doxytag: member="sedris::seTransmittal::setURN" ref="3aa9fd8e89b10029e2640b05e1d83cb7" args="(const char *urn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::setURN           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>urn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set (or modify) the URN for the transmittal. 
<p>
You are encouraged to always assign a URN to transmittals you create. Every transmittal should have a unique URN. The URN set by this method is stored in the transmittal file. URNs are of the form "urn:sedris:xyzcorp:xyz_data_orlando:1". <dl class="warning" compact><dt><b>Warning:</b></dt><dd>While all transmittals should have a URN assigned to them, care should be taken when invoking this function since the API is not responsible for managing configuration and changing control for the transmittal being modified. Calling this function will PERMANENTLY change the transmittal name associated with the file containing the SEDRIS transmittal. Be sure this is the desired result BEFORE calling this function. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The URN must pass the SE_ValidTransmittalName() function. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">seWorkspace::resolveTransmittalURN()</a>, <a class="el" href="a00316.htm#5c6b2486f236698ad8ddb417739e1330">seWorkspace::openTransmittalByURN()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>urn</em>&nbsp;</td><td>in: the new URN for the transmittal </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa2f09bfaf8f423e2e44a51c5cfbea6d"></a><!-- doxytag: member="sedris::seTransmittal::getURN" ref="fa2f09bfaf8f423e2e44a51c5cfbea6d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seTransmittal::getURN           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the transmittal URN associated with this transmittal. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the transmittal does not have a URN set, the returned string may be empty. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#3aa9fd8e89b10029e2640b05e1d83cb7">setURN()</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>URN of transmittal </dd></dl>

</div>
</div><p>
<a class="anchor" name="23d3d34b13e880d051a2f1eac6e86a61"></a><!-- doxytag: member="sedris::seTransmittal::getITRReferenceCount" ref="23d3d34b13e880d051a2f1eac6e86a61" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int sedris::seTransmittal::getITRReferenceCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of ITR referenced transmittals. 
<p>
A transmittal may contain objects that actually reference objects in other transmittals. The reference is both by a transmittal URN and the published label for an object in that transmittal. This method returns the total number of transmittals being referenced. <dl class="note" compact><dt><b>Note:</b></dt><dd>A transmittal may be referenced by more than one URN (aliases), but this method does not return the unique number of references. You will need to resolve a URN and compare file names to check for actual unique references. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#54d7717cd87806b86510fe3d439b33d2">getITRReference()</a>, <a class="el" href="a00315.htm#4ec20bb1cf2e5251c50649b604cbfc67">getITRReferenceLabelCount()</a>, <a class="el" href="a00315.htm#3addc269841882a309aa36413501560e">getITRReferenceLabel()</a>, <a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">seWorkspace::resolveTransmittalURN()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="54d7717cd87806b86510fe3d439b33d2"></a><!-- doxytag: member="sedris::seTransmittal::getITRReference" ref="54d7717cd87806b86510fe3d439b33d2" args="(unsigned int urn_index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seTransmittal::getITRReference           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>urn_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the URN for an ITR referenced transmittal by index. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#23d3d34b13e880d051a2f1eac6e86a61">getITRReferenceCount()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ec20bb1cf2e5251c50649b604cbfc67"></a><!-- doxytag: member="sedris::seTransmittal::getITRReferenceLabelCount" ref="4ec20bb1cf2e5251c50649b604cbfc67" args="(unsigned int urn_index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int sedris::seTransmittal::getITRReferenceLabelCount           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>urn_index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of labels being used to reference objects in a particular URN-referenced transmittal (by URN index). 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Objects can be published under more than one label, hence this method does not return the unique number of references. You will need to resolve a URN, open the transmittal, and get the published objects to check for actual unique references. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if the URN is not being referenced. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#23d3d34b13e880d051a2f1eac6e86a61">getITRReferenceCount()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3addc269841882a309aa36413501560e"></a><!-- doxytag: member="sedris::seTransmittal::getITRReferenceLabel" ref="3addc269841882a309aa36413501560e" args="(unsigned int urn_index, unsigned int label_index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seTransmittal::getITRReferenceLabel           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>urn_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>label_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the label (by label index) being used to reference an object in a particular URN-referenced transmittal (by URN index). 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#4ec20bb1cf2e5251c50649b604cbfc67">getITRReferenceLabelCount()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3335c551211928de6c801372ba91fa0b"></a><!-- doxytag: member="sedris::seTransmittal::getUniqueID" ref="3335c551211928de6c801372ba91fa0b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seTransmittal::getUniqueID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the transmittal unique identifier. 
<p>
Unique identifiers are assigned to transmittals every time a transmittal is modified and saved (for example after creation or update on transmittal closing). The unique identifier returned by this method is a character string suitable for printing, comparison, or storage operations.<p>
Unique identifiers are automatically managed by the API, so there are no methods that allow you to change or set them to specific values. You can use unique identifiers to compare two transmittals to see if they are in fact the same transmittals (for example two transmittals may have different file names but contain the same data). <div class="fragment"><pre class="fragment">            cout &lt;&lt; <span class="stringliteral">"Unique identifier is "</span> &lt;&lt; xmtal.getUniqueID() &lt;&lt; endl;
</pre></div> <dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>

</div>
</div><p>
<a class="anchor" name="09b2a5f6dd89fad3c11639229684dcae"></a><!-- doxytag: member="sedris::seTransmittal::cloneTo" ref="09b2a5f6dd89fad3c11639229684dcae" args="(seTransmittal &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::cloneTo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clones this instance handle into another transmittal handle. 
<p>
Used to make another <a class="el" href="a00315.htm">seTransmittal</a> refer to the same transmittal this instance refers to. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>in: transmittal to be cloned to </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="544346d889fb0d19419a8beef9ac8509"></a><!-- doxytag: member="sedris::seTransmittal::isSameAs" ref="544346d889fb0d19419a8beef9ac8509" args="(const seTransmittal &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seTransmittal::isSameAs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the transmittal passed in is a clone of this one (i.e. 
<p>
both handles reference the same transmittal). 
</div>
</div><p>
<a class="anchor" name="ba182f50d1f79e170e70a17d78cec0d2"></a><!-- doxytag: member="sedris::seTransmittal::release" ref="ba182f50d1f79e170e70a17d78cec0d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seTransmittal::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the handle to the transmittal. 
<p>
Generally there is no need to call this method, since <a class="el" href="a00315.htm#ba182f50d1f79e170e70a17d78cec0d2">release()</a> is called by any change of handle or when the object goes out of scope. <dl class="note" compact><dt><b>Note:</b></dt><dd>This method does not close the transmittal if there are other handles referring to the same transmittal. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#890e458a0f7ad1932cc34518434a3ae7">close()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2f867f56d8fae31f4ca71e09af5d7be"></a><!-- doxytag: member="sedris::seTransmittal::isInWorkspace" ref="b2f867f56d8fae31f4ca71e09af5d7be" args="(const seWorkspace &amp;wksp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seTransmittal::isInWorkspace           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00316.htm">seWorkspace</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wksp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this transmittal was opened in the passed-in workspace. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wksp</em>&nbsp;</td><td>in: handle to workspace </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if transmittal is in workspace </dd></dl>

</div>
</div><p>
<hr size="1">
<table width="100%">
<tr valign="middle">
<td align="left"><b>SEDRIS Transmittal Access C++ API</b></td>
<td align="right"><b>Version 4.1.4 - 14 Sep 2010</b></td>
</tr>
<tr valign="middle">
<td align="left">Copyright &copy; 2010 <a href="http://www.sedris.org">SEDRIS</a>&trade;</td>
<td align="right">Docs by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.4.7-20061004</td>
</tr>
</table>
</body>
</html>
