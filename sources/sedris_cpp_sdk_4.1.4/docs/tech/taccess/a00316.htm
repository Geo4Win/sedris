<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SEDRIS Transmittal Access C++ API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#FFFFFF">

<!-- Generated by Doxygen 1.4.7-20061004 -->
<div class="tabs">
  <ul>
    <li><a href="main.htm"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.htm"><span>Modules</span></a></li>
    <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.htm"><span>Classes</span></a></li>
    <li><a href="files.htm"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.htm"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.htm"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.htm"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.htm"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00635.htm">sedris</a>::<a class="el" href="a00316.htm">seWorkspace</a></div>
<h1>sedris::seWorkspace Class Reference</h1><!-- doxytag: class="sedris::seWorkspace" -->The <a class="el" href="a00316.htm">seWorkspace</a> class groups access to transmittals under a common "theme".  
<a href="#_details">More...</a>
<p>
<code>#include &lt;seWorkspace.h&gt;</code>
<p>
<a href="a01587.htm">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#e0d3d92ff368276628a02c2741664cc1">seWorkspace</a> (const char *name=NULL, const char *params=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates and opens an <a class="el" href="a00316.htm">seWorkspace</a>.  <a href="#e0d3d92ff368276628a02c2741664cc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#fc80507cab850e05d60bef7edc716940">~seWorkspace</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor, calls <a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">close()</a> if workspace is opened.  <a href="#fc80507cab850e05d60bef7edc716940"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#09ddd0fef60d3eeb6b89ce56368441c5">open</a> (const char *name=NULL, const char *params=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a previously closed workspace.  <a href="#09ddd0fef60d3eeb6b89ce56368441c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the workspace and releases the handle to the workspace.  <a href="#393266acc865b5d61f86cddec2de2ee4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#3cbc91cd1b81292c52d2b2c7d2371b15">isOpened</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this workspace is opened.  <a href="#3cbc91cd1b81292c52d2b2c7d2371b15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#e4f904050ebcaca74dab42154c47e746">setName</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the workspace name.  <a href="#e4f904050ebcaca74dab42154c47e746"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#8ad0928300ab5a9fa9aeca3d65eddc9f">getName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the workspace name.  <a href="#8ad0928300ab5a9fa9aeca3d65eddc9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#b636e86386404715cd6b56f226fd87aa">openTransmittalByFile</a> (const char *file_name, <a class="el" href="a00315.htm">seTransmittal</a> &amp;xmtal, SE_Access_Mode access_mode=SE_AM_READ_ONLY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a transmittal by file using the access mode specified.  <a href="#b636e86386404715cd6b56f226fd87aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#3ff98974a6d679d7d5bddf5a299d12e8">createTransmittal</a> (const char *file_name, <a class="el" href="a00315.htm">seTransmittal</a> &amp;xmtal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a transmittal.  <a href="#3ff98974a6d679d7d5bddf5a299d12e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#597fedc0617189ff8dcd0bab8a6b5970">editTransmittal</a> (const char *file_name, <a class="el" href="a00315.htm">seTransmittal</a> &amp;xmtal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a transmittal for edit.  <a href="#597fedc0617189ff8dcd0bab8a6b5970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#5c6b2486f236698ad8ddb417739e1330">openTransmittalByURN</a> (const char *xmtal_urn, <a class="el" href="a00315.htm">seTransmittal</a> &amp;xmtal, SE_Access_Mode access_mode=SE_AM_READ_ONLY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a transmittal by its URN.  <a href="#5c6b2486f236698ad8ddb417739e1330"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#0854f01189ab87766c97e44704b1f96c">getOpenedTransmittalCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current number of opened transmittals in this workspace.  <a href="#0854f01189ab87766c97e44704b1f96c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#5a76f4d31cca0d0c6819475f08b83224">getOpenedTransmittal</a> (unsigned int index, <a class="el" href="a00315.htm">seTransmittal</a> &amp;xmtal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a handle to an opened transmittal by index.  <a href="#5a76f4d31cca0d0c6819475f08b83224"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">resolveTransmittalURN</a> (const char *xmtal_urn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolves a transmittal URN to a transmittal resource location.  <a href="#ce32f762f4b72693832bcf8fc23e5312"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#0fe0f6e5c7cf00baa237293598e5b2c4">createUnresolvedObject</a> (const char *xmtal_urn, const char *obj_label, <a class="el" href="a00313.htm">seObject</a> &amp;obj) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an unresolved object that references an object in another transmittal.  <a href="#0fe0f6e5c7cf00baa237293598e5b2c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#6a09c85986f3056978af14bb5275dc06">setITRBehaviour</a> (SE_ITR_Behaviour itr_behaviour)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ITR behaviour to use in the workspace from now on.  <a href="#6a09c85986f3056978af14bb5275dc06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual SE_ITR_Behaviour&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#19383f81c51742fc2d9541df15c23150">getITRBehaviour</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the workspace ITR behaviour.  <a href="#19383f81c51742fc2d9541df15c23150"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#cf125641ba6f137284069340acd6e25d">setAccessModeInheritance</a> (bool tf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether access modes are inherited by the automatic ITR resolution process.  <a href="#cf125641ba6f137284069340acd6e25d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#f266e486122a88f9eca43287b01fb198">getAccessModeInheritance</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the workspace access mode inheritance flag.  <a href="#f266e486122a88f9eca43287b01fb198"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#daf9a7c55fd4862fa52288a73ab1600d">setITRResolverPath</a> (const char *new_path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ITR resolver path to use in the workspace from now on.  <a href="#daf9a7c55fd4862fa52288a73ab1600d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#a6fcccd4ea763847f78afd6599be057a">getITRResolverPath</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the workspace resolver path.  <a href="#a6fcccd4ea763847f78afd6599be057a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#17ef66d63d38641d95575273086a2725">setMemoryModel</a> (unsigned int mem_model)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the memory model used by transmittals.  <a href="#17ef66d63d38641d95575273086a2725"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#fb3f243f8d4b4a9b775bfdc769c9b58c">getMemoryModel</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the memory model in use by the workspace.  <a href="#fb3f243f8d4b4a9b775bfdc769c9b58c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27562b14fd1a84174b73e6d4fb7aac98"></a><!-- doxytag: member="sedris::seWorkspace::getImplVerInfo" ref="27562b14fd1a84174b73e6d4fb7aac98" args="() const " -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#27562b14fd1a84174b73e6d4fb7aac98">getImplVerInfo</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the implementation version of the API component. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8016302203ede09bcccbb71b2c4e681c"></a><!-- doxytag: member="sedris::seWorkspace::seWorkspace" ref="8016302203ede09bcccbb71b2c4e681c" args="(const seWorkspace &amp;other)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#8016302203ede09bcccbb71b2c4e681c">seWorkspace</a> (const <a class="el" href="a00316.htm">seWorkspace</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not allowed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0513459e1cd141a8d3975d282457bc6"></a><!-- doxytag: member="sedris::seWorkspace::operator=" ref="f0513459e1cd141a8d3975d282457bc6" args="(const seWorkspace &amp;)" -->
<a class="el" href="a00316.htm">seWorkspace</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.htm#f0513459e1cd141a8d3975d282457bc6">operator=</a> (const <a class="el" href="a00316.htm">seWorkspace</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not allowed. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="a00316.htm">seWorkspace</a> class groups access to transmittals under a common "theme". 
<p>
You can, for example, specify the ITR behaviour, resolver path, etc. to use when opening transmittals so that all transmittals under that workspace are opened and accessed using the same parameters.<p>
When an <a class="el" href="a00316.htm">seWorkspace</a> instance is deleted (for example, when it goes out of scope) the workspace is automatically closed, which forces the closing of all opened transmittals in the workspace (see <a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">seWorkspace::close()</a>). All handles to <a class="el" href="a00315.htm">seTransmittal</a> and <a class="el" href="a00313.htm">seObject</a> instances remain valid, but the operations that can be performed on them will be greatly limited to only those that don't require access to the transmittal.<p>
Example usage: <div class="fragment"><pre class="fragment">    <a class="code" href="a00316.htm#e0d3d92ff368276628a02c2741664cc1">seWorkspace</a> wksp;
    seTransmittal xmtal1, xmtal2;

    wksp.setITRResolverPath(myResolverPath);

    wksp.openTransmittalByFile(fileName1, xmtal1);
    wksp.openTransmittalByFile(fileName2, xmtal2);
    ... work on transmittals
</pre></div> <dl class="warning" compact><dt><b>Warning:</b></dt><dd>You can change the parameters of a workspace at any time, but be aware that transmittals don't "remember" the settings they were opened with, and that ALL the transmittals in that workspace will be using the new parameters from the moment the settings were changed. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>on error. </td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Warren Macchi (Accent Geographic) </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm">seTransmittal</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e0d3d92ff368276628a02c2741664cc1"></a><!-- doxytag: member="sedris::seWorkspace::seWorkspace" ref="e0d3d92ff368276628a02c2741664cc1" args="(const char *name=NULL, const char *params=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sedris::seWorkspace::seWorkspace           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates and opens an <a class="el" href="a00316.htm">seWorkspace</a>. 
<p>
Workspaces are the only way to open transmittals. You can keep as many workspaces as you need to group the opening/creation/access to transmittals. You can <a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">close()</a> and re <a class="el" href="a00316.htm#09ddd0fef60d3eeb6b89ce56368441c5">open()</a> a workspace with the caveates as explained in those methods. <dl class="note" compact><dt><b>Note:</b></dt><dd>There is no need to call <a class="el" href="a00316.htm#09ddd0fef60d3eeb6b89ce56368441c5">open()</a> unless you close the workspace. <p>
The <code>name</code> and <code>params</code> parameters are currently experimental. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#e4f904050ebcaca74dab42154c47e746">setName()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>in (optional): the name to use for this workspace </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>in (optional): parameters to use in the workspace creation (experimental) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fc80507cab850e05d60bef7edc716940"></a><!-- doxytag: member="sedris::seWorkspace::~seWorkspace" ref="fc80507cab850e05d60bef7edc716940" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sedris::seWorkspace::~seWorkspace           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor, calls <a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">close()</a> if workspace is opened. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">close()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="09ddd0fef60d3eeb6b89ce56368441c5"></a><!-- doxytag: member="sedris::seWorkspace::open" ref="09ddd0fef60d3eeb6b89ce56368441c5" args="(const char *name=NULL, const char *params=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a previously closed workspace. 
<p>
<div class="fragment"><pre class="fragment">            <a class="code" href="a00316.htm#e0d3d92ff368276628a02c2741664cc1">seWorkspace</a> wksp(<span class="stringliteral">"a name"</span>); <span class="comment">// implicit open()</span>
            ...
            wksp.openTransmittalByFile(...);
            ...
            wksp.close();
            ...
            wksp.open(<span class="stringliteral">"another name"</span>);
            wksp.openTransmittalByFile(...);
</pre></div> <dl class="note" compact><dt><b>Note:</b></dt><dd>Normally you would not need to <a class="el" href="a00316.htm#09ddd0fef60d3eeb6b89ce56368441c5">open()</a> or <a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">close()</a> workspaces. The constructor can take the same parameters given here, and the destructor takes care of the closing (if the workspace is still open). <p>
If the workspace was already open, an <a class="el" href="a00307.htm">seException</a> is thrown. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#393266acc865b5d61f86cddec2de2ee4">close()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="393266acc865b5d61f86cddec2de2ee4"></a><!-- doxytag: member="sedris::seWorkspace::close" ref="393266acc865b5d61f86cddec2de2ee4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes the workspace and releases the handle to the workspace. 
<p>
All transmittals opened by this workspace are closed.<p>
Note that after a workspace handle is closed you can't do much with the workspace handle. To make the workspace handle valid again you must call <a class="el" href="a00316.htm#09ddd0fef60d3eeb6b89ce56368441c5">open()</a> to re-open the workspace. <dl class="note" compact><dt><b>Note:</b></dt><dd>Closing a workspace forces the closing of all opened transmittals in that workspace. <p>
<a class="el" href="a00315.htm">seTransmittal</a> and <a class="el" href="a00313.htm">seObject</a> handles remain valid, but you won't be able to do much with them except to release them. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#890e458a0f7ad1932cc34518434a3ae7">seTransmittal::close()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3cbc91cd1b81292c52d2b2c7d2371b15"></a><!-- doxytag: member="sedris::seWorkspace::isOpened" ref="3cbc91cd1b81292c52d2b2c7d2371b15" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seWorkspace::isOpened           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this workspace is opened. 
<p>
<div class="fragment"><pre class="fragment">            <a class="code" href="a00316.htm#e0d3d92ff368276628a02c2741664cc1">seWorkspace</a> wksp;
            ...
            <span class="keywordflow">if</span> (wksp.isOpened())
                cout &lt;&lt; <span class="stringliteral">"Workspace is opened"</span>;
</pre></div> 
</div>
</div><p>
<a class="anchor" name="e4f904050ebcaca74dab42154c47e746"></a><!-- doxytag: member="sedris::seWorkspace::setName" ref="e4f904050ebcaca74dab42154c47e746" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the workspace name. 
<p>
Note that workspaces can have a name but the names are inconsequential and are not required for normal operation. An application can set the name to whatever string it wants. <dl class="note" compact><dt><b>Note:</b></dt><dd>If no name is provided for the workspace, a default name will be used. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>in: the name for the workspace </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8ad0928300ab5a9fa9aeca3d65eddc9f"></a><!-- doxytag: member="sedris::seWorkspace::getName" ref="8ad0928300ab5a9fa9aeca3d65eddc9f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seWorkspace::getName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the workspace name. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>

</div>
</div><p>
<a class="anchor" name="b636e86386404715cd6b56f226fd87aa"></a><!-- doxytag: member="sedris::seWorkspace::openTransmittalByFile" ref="b636e86386404715cd6b56f226fd87aa" args="(const char *file_name, seTransmittal &amp;xmtal, SE_Access_Mode access_mode=SE_AM_READ_ONLY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::openTransmittalByFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xmtal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SE_Access_Mode&nbsp;</td>
          <td class="paramname"> <em>access_mode</em> = <code>SE_AM_READ_ONLY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a transmittal by file using the access mode specified. 
<p>
This is the general way to open a transmittal by specifying its file name and path. You can also use the convenience methods <a class="el" href="a00316.htm#3ff98974a6d679d7d5bddf5a299d12e8">createTransmittal()</a> and <a class="el" href="a00316.htm#597fedc0617189ff8dcd0bab8a6b5970">editTransmittal()</a> to create and edit transmittals, respectively. <div class="fragment"><pre class="fragment">            <a class="code" href="a00316.htm#e0d3d92ff368276628a02c2741664cc1">seWorkspace</a> wksp;
            seTransmittal xmtal;
            seDRMTransmittalRoot root_obj;

            wksp.openTransmittalByFile(<span class="stringliteral">"transmittals/test.stf"</span>, xmtal);
            cout &lt;&lt; xmtal.getFileName() &lt;&lt; <span class="stringliteral">" is now opened"</span>;
            xmtal.getRootObject(root_obj);
            ... process transmittal hierarchy
</pre></div> <dl class="note" compact><dt><b>Note:</b></dt><dd>If no access mode parameter is provided, the transmittal is opened read only (SE_AM_READ_ONLY). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#3ff98974a6d679d7d5bddf5a299d12e8">createTransmittal()</a>, <a class="el" href="a00316.htm#597fedc0617189ff8dcd0bab8a6b5970">editTransmittal()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file_name</em>&nbsp;</td><td>in: file name and path of transmittal to open </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmtal</em>&nbsp;</td><td>in/out: the recipient transmittal handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>access_mode</em>&nbsp;</td><td>in (optional): access mode, use SE_AM_READ_ONLY, SE_AM_CREATE, SE_AM_UPDATE </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3ff98974a6d679d7d5bddf5a299d12e8"></a><!-- doxytag: member="sedris::seWorkspace::createTransmittal" ref="3ff98974a6d679d7d5bddf5a299d12e8" args="(const char *file_name, seTransmittal &amp;xmtal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::createTransmittal           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xmtal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a transmittal. 
<p>
Convenience method for <a class="el" href="a00316.htm#b636e86386404715cd6b56f226fd87aa">openTransmittalByFile()</a> in CREATE mode. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>If the transmittal file is already there, this method will OVERWRITE that transmittal. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#b636e86386404715cd6b56f226fd87aa">openTransmittalByFile()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file_name</em>&nbsp;</td><td>in: file name and path of transmittal to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmtal</em>&nbsp;</td><td>in/out: the recipient transmittal handle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="597fedc0617189ff8dcd0bab8a6b5970"></a><!-- doxytag: member="sedris::seWorkspace::editTransmittal" ref="597fedc0617189ff8dcd0bab8a6b5970" args="(const char *file_name, seTransmittal &amp;xmtal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::editTransmittal           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xmtal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a transmittal for edit. 
<p>
Convenience method for <a class="el" href="a00316.htm#b636e86386404715cd6b56f226fd87aa">openTransmittalByFile()</a> in UPDATE mode. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00307.htm">seException</a></em>&nbsp;</td><td>if the transmittal file does not exist. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#b636e86386404715cd6b56f226fd87aa">openTransmittalByFile()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file_name</em>&nbsp;</td><td>in: file name and path of transmittal to edit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmtal</em>&nbsp;</td><td>in/out: the recipient transmittal handle </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if successful </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c6b2486f236698ad8ddb417739e1330"></a><!-- doxytag: member="sedris::seWorkspace::openTransmittalByURN" ref="5c6b2486f236698ad8ddb417739e1330" args="(const char *xmtal_urn, seTransmittal &amp;xmtal, SE_Access_Mode access_mode=SE_AM_READ_ONLY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::openTransmittalByURN           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>xmtal_urn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xmtal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SE_Access_Mode&nbsp;</td>
          <td class="paramname"> <em>access_mode</em> = <code>SE_AM_READ_ONLY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a transmittal by its URN. 
<p>
The API uses resolver files to map a URN to a resource location (typically a file on a disk). See <a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">resolveTransmittalURN()</a> for more information on resolver files. <dl class="note" compact><dt><b>Note:</b></dt><dd>URNs are assigned to transmittals by calling setURN() on transmittals opened in create or update mode. <p>
This method is a convenience method to manually resolve a URN by calling <a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">resolveTransmittalURN()</a>, and then calling <a class="el" href="a00316.htm#b636e86386404715cd6b56f226fd87aa">openTransmittalByFile()</a> with the resolved resource location. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00315.htm#3aa9fd8e89b10029e2640b05e1d83cb7">seTransmittal::setURN()</a>, <a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">resolveTransmittalURN()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xmtal_urn</em>&nbsp;</td><td>in: URN of transmittal to open </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmtal</em>&nbsp;</td><td>in/out: the recipient transmittal handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>access_mode</em>&nbsp;</td><td>in (optional): access mode, use SE_AM_READ_ONLY, SE_AM_CREATE, SE_AM_UPDATE </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if successful </dd></dl>

</div>
</div><p>
<a class="anchor" name="0854f01189ab87766c97e44704b1f96c"></a><!-- doxytag: member="sedris::seWorkspace::getOpenedTransmittalCount" ref="0854f01189ab87766c97e44704b1f96c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int sedris::seWorkspace::getOpenedTransmittalCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current number of opened transmittals in this workspace. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#5a76f4d31cca0d0c6819475f08b83224">getOpenedTransmittal()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a76f4d31cca0d0c6819475f08b83224"></a><!-- doxytag: member="sedris::seWorkspace::getOpenedTransmittal" ref="5a76f4d31cca0d0c6819475f08b83224" args="(unsigned int index, seTransmittal &amp;xmtal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::getOpenedTransmittal           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00315.htm">seTransmittal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xmtal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle to an opened transmittal by index. 
<p>
<div class="fragment"><pre class="fragment">            <a class="code" href="a00316.htm#e0d3d92ff368276628a02c2741664cc1">seWorkspace</a> wksp;
            ... <a class="code" href="a00316.htm#09ddd0fef60d3eeb6b89ce56368441c5">open</a> transmittals

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wksp.getOpenedTransmittalCount(); i++)
            {
                seTransmittal xmtal;
                wksp.getOpenedTransmittal(i, xmtal);
                cout &lt;&lt; xmtal.getFileName() &lt;&lt; <span class="stringliteral">" is opened"</span> &lt;&lt; endl;
            }
</pre></div> <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#0854f01189ab87766c97e44704b1f96c">getOpenedTransmittalCount()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>in: index of transmittal to return </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmtal</em>&nbsp;</td><td>in/out: the recipient transmittal handle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ce32f762f4b72693832bcf8fc23e5312"></a><!-- doxytag: member="sedris::seWorkspace::resolveTransmittalURN" ref="ce32f762f4b72693832bcf8fc23e5312" args="(const char *xmtal_urn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seWorkspace::resolveTransmittalURN           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>xmtal_urn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolves a transmittal URN to a transmittal resource location. 
<p>
The API uses a search mechanism to look for resolver files with the appropriate mapping of a URN to a resource. The default extension for SEDRIS resolver files is ".rsl".<p>
The resolution process proceeds as follows until the URN is resolved: <ol>
<li>
Use each opened transmittal's filename and replace their extension with ".rsl". For each transmittal, if a matching file is found, see if the resolution can be completed from its contents. </li>
<li>
Use the environment variable SEDRIS_RESOLVER_PATH to search for "sedris.rsl" in its list of search directories. </li>
<li>
Use the workspace's search paths (set with setResolverPath()) to look for "sedris.rsl" in its list of search directories. </li>
</ol>
An example line in a SEDRIS resolver file may look like: <div class="fragment"><pre class="fragment">            TRANSMITTAL urn:sedris:xyzcorp:xyz_data_orlando:1 4.1:stf:4.1 file:///${CUR_RESOLVE_DIR}\xyz_mco.stf
        </pre></div> <div class="fragment"><pre class="fragment">            <a class="code" href="a00316.htm#e0d3d92ff368276628a02c2741664cc1">seWorkspace</a> wksp;
            <span class="keyword">const</span> <span class="keywordtype">char</span> *urn = <span class="stringliteral">"urn:sedris:xyzcorp:xyz_data_orlando:1"</span>;
            std::string file_path;

            file_path = wksp.resolveTransmittalURN(urn);

            <span class="keywordflow">if</span> (!file_path.empty())
            {
                cout &lt;&lt; <span class="stringliteral">"Transmittal is at "</span> &lt;&lt; file_path &lt;&lt; endl;
            }
</pre></div><p>
The format of a valid SEDRIS name is as follows: urn:sedris:&lt;delegated_creation_authority&gt;:&lt;assigned_transmittal_name&gt; [:&lt;transmittal_version_serial&gt;] <dl class="note" compact><dt><b>Note:</b></dt><dd>In the format shown above there must be <em>no</em> white space or carriage control characters within or between the sub-fields.</dd></dl>
The format as described here is for cursory information only. Please consult the SEDRIS documentation set for a complete and formal description of the SEDRIS namespace and resolution process.<p>
The first 11 characters are <em>required</em> fields that represent a sentinel for the SEDRIS namespace. These fields <em>must</em> be present for the name string to be considered valid.<p>
The &lt;delegated_creation_authority&gt; is the string representing the portion of the SEDRIS namespace that has been delegated by the SEDRIS namespace registrar to the group, organization, or body that has authority for the assignment of transmittal named within the delegated namespace. This string may represent a sub-delegation by the registered authority to another group, organization or body.<p>
The &lt;assigned_transmittal_name&gt; is the string representing a specific transmittal, and the optional &lt;transmittal_version_serial&gt; allows for a more specific designation of the transmittal to resolve. The rules governing the naming and versioning of SEDRIS transmittals are described more fully in the SEDRIS documentation set.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#daf9a7c55fd4862fa52288a73ab1600d">setITRResolverPath()</a>, <a class="el" href="a00316.htm#5c6b2486f236698ad8ddb417739e1330">openTransmittalByURN()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xmtal_urn</em>&nbsp;</td><td>in: transmittal URN to resolve </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the transmittal resource location if successful, an empty string otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="0fe0f6e5c7cf00baa237293598e5b2c4"></a><!-- doxytag: member="sedris::seWorkspace::createUnresolvedObject" ref="0fe0f6e5c7cf00baa237293598e5b2c4" args="(const char *xmtal_urn, const char *obj_label, seObject &amp;obj) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::createUnresolvedObject           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>xmtal_urn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>obj_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00313.htm">seObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an unresolved object that references an object in another transmittal. 
<p>
This method is used to create an object that references an object in another transmittal using the ITR mechanism. You can use the returned object pretty much like you would use any other object (for example you can add it as a component/associate of another). However, you cannot call methods that require it to be resolved since they will fail with an exception.<p>
For example, to create an ITR reference to transmittal B and to add a published object B in that transmittal as a component of object A in transmittal A, you can do: <div class="fragment"><pre class="fragment">            ...
            seObject itr_obj;

            wksp.createUnresolvedObject(urn_B, label_B, itr_obj);
            obj_A.addComponent(itr_obj);
</pre></div> If you need to add the reverse (aggregate) relationship in the B transmittal, you could do (assuming that object A was published with label A): <div class="fragment"><pre class="fragment">            ...
            seObject itr_obj;

            wksp.createUnresolvedObject(urn_A, label_A, itr_obj);
            itr_obj.addComponent(obj_B);
</pre></div> <dl class="warning" compact><dt><b>Warning:</b></dt><dd>This function does not validate the reference to insure that it can be resolved. This behavior is intentional in order to allow referencing "well known" published objects, without requiring the transmittal containing the object to be accessible. Care must be taken to insure the reference is indeed correct. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The transmittal URN must pass SE_ValidTransmittalName() and the object label must pass SE_ValidObjectLabel(), or an exception will occur. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xmtal_urn</em>&nbsp;</td><td>in: the URN of the transmittal to reference </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj_label</em>&nbsp;</td><td>in: the label of the published object in the referenced transmittal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>in/out: a handle to store the created object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6a09c85986f3056978af14bb5275dc06"></a><!-- doxytag: member="sedris::seWorkspace::setITRBehaviour" ref="6a09c85986f3056978af14bb5275dc06" args="(SE_ITR_Behaviour itr_behaviour)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::setITRBehaviour           </td>
          <td>(</td>
          <td class="paramtype">SE_ITR_Behaviour&nbsp;</td>
          <td class="paramname"> <em>itr_behaviour</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the ITR behaviour to use in the workspace from now on. 
<p>
The ITR behaviour determines how iterators and objects behave when they encounter an ITR reference. See <a class="el" href="a00312.htm">seIterator</a> and <a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">seIterator::getNext()</a> for more information on iterator behaviour.<p>
See the documentation for the SE_ITR_Behaviour type for more information on ITR and API operation. <dl class="note" compact><dt><b>Note:</b></dt><dd>The default behaviour is to resolve objects. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00312.htm#6cba602f18db5316be62c25a295eb080">seIterator::getNext()</a>, <a class="el" href="a00316.htm#0fe0f6e5c7cf00baa237293598e5b2c4">createUnresolvedObject()</a>, <a class="el" href="a00313.htm#fb8d8d28e3887352fddc3bd22f943fe0">seObject::isResolved()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>itr_behaviour</em>&nbsp;</td><td>in: the new ITR behaviour to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19383f81c51742fc2d9541df15c23150"></a><!-- doxytag: member="sedris::seWorkspace::getITRBehaviour" ref="19383f81c51742fc2d9541df15c23150" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SE_ITR_Behaviour sedris::seWorkspace::getITRBehaviour           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the workspace ITR behaviour. 
<p>
@see <a class="el" href="a00316.htm#6a09c85986f3056978af14bb5275dc06">setITRBehaviour()</a> 
</div>
</div><p>
<a class="anchor" name="cf125641ba6f137284069340acd6e25d"></a><!-- doxytag: member="sedris::seWorkspace::setAccessModeInheritance" ref="cf125641ba6f137284069340acd6e25d" args="(bool tf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::setAccessModeInheritance           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether access modes are inherited by the automatic ITR resolution process. 
<p>
This flag indicates whether the access mode used when opening transmittals should be propagated to transmittals opened by the automatic ITR resolution process (see <a class="el" href="a00316.htm#6a09c85986f3056978af14bb5275dc06">setITRBehaviour()</a>).<p>
For example, if you open a transmittal in update mode and the access mode inheritance flag is set to true and ITR behaviour is set to automatically resolve, then all transmittals being referenced will also be opened in update mode.<p>
If this flag is set to false, then (if automatic resolution is enabled) ITR references will be opened in read only mode. <dl class="note" compact><dt><b>Note:</b></dt><dd>The default is false (access mode is not inherited). <p>
If you are updating a transmittal, then you would probably want to set this flag to true so that dependent transmittals are also opened in update mode. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Setting this flag to true may cause changes (when in update mode) to more than one transmittal. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tf</em>&nbsp;</td><td>in: boolean flag </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f266e486122a88f9eca43287b01fb198"></a><!-- doxytag: member="sedris::seWorkspace::getAccessModeInheritance" ref="f266e486122a88f9eca43287b01fb198" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sedris::seWorkspace::getAccessModeInheritance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the workspace access mode inheritance flag. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#cf125641ba6f137284069340acd6e25d">setAccessModeInheritance()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="daf9a7c55fd4862fa52288a73ab1600d"></a><!-- doxytag: member="sedris::seWorkspace::setITRResolverPath" ref="daf9a7c55fd4862fa52288a73ab1600d" args="(const char *new_path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::setITRResolverPath           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>new_path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the ITR resolver path to use in the workspace from now on. 
<p>
The resolver path is used to find resolver files when resolving a transmittal URN to an actual resource (typically a disk file).<p>
You may specify multiple directories by separating them with colons (:) in Unix systems or semicolons (;) in Win32 systems. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">resolveTransmittalURN()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_path,:</em>&nbsp;</td><td>the new resolver path to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a6fcccd4ea763847f78afd6599be057a"></a><!-- doxytag: member="sedris::seWorkspace::getITRResolverPath" ref="a6fcccd4ea763847f78afd6599be057a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sedris::seWorkspace::getITRResolverPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the workspace resolver path. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Pointers to string memory are temporary, and should not be stored by the user. If you need to store the pointed-to string, copy the string data to your own memory space (for example into a std::string). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#daf9a7c55fd4862fa52288a73ab1600d">setITRResolverPath()</a>, <a class="el" href="a00316.htm#ce32f762f4b72693832bcf8fc23e5312">resolveTransmittalURN()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="17ef66d63d38641d95575273086a2725"></a><!-- doxytag: member="sedris::seWorkspace::setMemoryModel" ref="17ef66d63d38641d95575273086a2725" args="(unsigned int mem_model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sedris::seWorkspace::setMemoryModel           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mem_model</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the memory model used by transmittals. 
<p>
The operation of the memory model is transmittal implementation dependent.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The default value is 0, which lets the transmittal implementation choose its own value. <p>
A memory model is only applicable when a transmittal is opened. It has no effect on already opened transmittals. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This method is experimental. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem_model</em>&nbsp;</td><td>in: new memory model to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fb3f243f8d4b4a9b775bfdc769c9b58c"></a><!-- doxytag: member="sedris::seWorkspace::getMemoryModel" ref="fb3f243f8d4b4a9b775bfdc769c9b58c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int sedris::seWorkspace::getMemoryModel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the memory model in use by the workspace. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00316.htm#17ef66d63d38641d95575273086a2725">setMemoryModel()</a> </dd></dl>

</div>
</div><p>
<hr size="1">
<table width="100%">
<tr valign="middle">
<td align="left"><b>SEDRIS Transmittal Access C++ API</b></td>
<td align="right"><b>Version 4.1.4 - 14 Sep 2010</b></td>
</tr>
<tr valign="middle">
<td align="left">Copyright &copy; 2010 <a href="http://www.sedris.org">SEDRIS</a>&trade;</td>
<td align="right">Docs by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.4.7-20061004</td>
</tr>
</table>
</body>
</html>
